# ===============================================================================
# RFS Station Manager - Comprehensive CI/CD Pipeline
# ===============================================================================
# 
# Purpose:
#   Automated quality assurance, testing, and deployment pipeline with strict
#   quality gates to ensure no broken code reaches production.
#
# Pipeline Stages:
#   1. Quality Checks (parallel) - Linting, type checking, security scanning
#   2. Testing (parallel) - Unit tests, integration tests, coverage reporting
#   3. Build - Production build artifacts
#   4. Deploy - Optimized deployment to Azure (only if all checks pass)
#   5. Post-Deployment Tests - Smoke tests against live deployment
#
# Quality Gates:
#   - All linting must pass (zero errors, zero warnings)
#   - Type checking must pass (TypeScript strict mode)
#   - All tests must pass (45+ tests)
#   - Build must succeed
#   - Deployment only occurs if all above gates pass
#   - Post-deployment tests validate live application
#
# Deployment Strategy:
#   OPTIMIZED FOR SPEED:
#
#   Artifact Packaging:
#     - Ships pre-built backend/dist (compiled TypeScript)
#     - Ships pre-built frontend/dist (optimized static assets)
#     - Ships package.json and package-lock.json (for Azure npm install)
#     - Does NOT ship source code (.ts files)
#     - Does NOT ship node_modules (installed by Azure post-deploy)
#
#   Azure App Service Deployment (Windows/IIS):
#     - SCM_DO_BUILD_DURING_DEPLOYMENT=true (enables post-deploy npm install)
#     - Dependencies installed by Azure after code deployment
#     - Faster GitHub Actions execution (no dependency installation in CI)
#     - Ensures consistent environment with locked dependencies
#     - Retry logic handles transient 409 Conflict errors
#
#   Why Azure Installs Dependencies:
#     - Significantly faster GitHub Actions execution
#     - Smaller deployment artifacts (no node_modules transfer)
#     - Azure handles npm install after code is pushed
#     - Deterministic builds with exact versions from package-lock.json
#
#   Deployment Reliability:
#     - Automatic retry on 409 Conflict errors (common with Oryx builds)
#     - 60-second wait between retries to allow Azure to complete previous operations
#     - Handles transient deployment conflicts gracefully
#
#   Benefits:
#     - Faster CI/CD pipeline (less time in GitHub Actions)
#     - Smaller deployment packages
#     - Deterministic builds (exact versions from package-lock.json)
#     - No redundant dependency installation during CI
#     - Resilient to transient Azure deployment conflicts
#
# Post-Deployment Testing Strategy:
#   TWO-PHASE APPROACH FOR EFFICIENCY:
#
#   Phase 1: Stabilization (up to 5 minutes)
#     - Polls health endpoint every 10 seconds
#     - Validates site is responding AND correct version is deployed
#     - Exits immediately when both conditions met (efficient!)
#     - Maximum: 30 attempts Ã— 10s = 300s (5 minutes)
#     - Typical: 1-2 minutes (exits early when ready)
#
#   Phase 2: Functional Tests (minimal retries)
#     - Runs only after stabilization confirms site is ready
#     - Each test gets 2 quick retries (5s between) for transient issues
#     - Tests fail fast since site is known to be up
#     - Expected completion: 30-60 seconds for all 7 tests
#
#   Total Maximum Time: 5 min stabilization + 2 min tests = 7 minutes
#   Typical Time: 2 min stabilization + 1 min tests = 3 minutes
#
#   This is efficient because:
#     - Stabilization happens once, upfront
#     - No duplicate health checks across tests
#     - Functional tests run fast with minimal retries
#     - Early exit when site is ready (no wasted time)
#
#   Environment Variables:
#     - Uses TABLE_STORAGE_TABLE_SUFFIX=Test for isolated test data
#     - Leverages existing OIDC authentication (no secrets needed)
#     - Validates database connectivity and API responsiveness
#
# Optimizations:
#   - Parallel job execution for independent tasks
#   - Dependency caching (npm)
#   - Concurrency control (cancels outdated PR runs)
#   - Path filtering: Skip pipeline for documentation-only changes
#     (docs/**, *.md files) to reduce deployment frequency
#   - Optimized artifact packaging (no node_modules in deployment)
#   - Azure post-deploy builds (SCM_DO_BUILD_DURING_DEPLOYMENT=true)
#
# Future Optimizations:
#   - Conditional execution based on file changes (future enhancement)
#
# Failure Handling:
#   - Detailed error logs in workflow output
#   - Automatic issue creation on failure (see create-issue-on-failure.yml)
#
# Documentation:
#   - See docs/ci_pipeline.md for detailed pipeline documentation
#   - See docs/MASTER_PLAN.md for strategic planning
#
# Maintenance:
#   - Review and update periodically
#   - Monitor GitHub Actions minutes usage
#   - Optimize caching strategies as project grows
#
# ===============================================================================

name: CI/CD Pipeline

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.github/*.md'
  pull_request:
    branches:
      - main
  workflow_dispatch:

# Cancel in-progress runs for the same PR/branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: '22.x'
  NPM_CACHE_KEY: 'npm-cache-v1'

jobs:
  # ===========================================================================
  # PHASE 1: QUALITY CHECKS (Parallel Execution)
  # ===========================================================================
  # These jobs run in parallel to quickly identify quality issues
  # All must pass before build/test/deploy can proceed
  # ===========================================================================

  # ---------------------------------------------------------------------------
  # Frontend Linting
  # ---------------------------------------------------------------------------
  # Enforces code quality, style consistency, and catches common errors
  # Uses ESLint with TypeScript parser and React hooks plugin
  lint-frontend:
    name: ðŸ” Lint Frontend
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci

      - name: Run ESLint
        run: |
          cd frontend
          npm run lint

  # ---------------------------------------------------------------------------
  # Backend Type Checking
  # ---------------------------------------------------------------------------
  # Validates TypeScript types and catches type errors in backend
  typecheck-backend:
    name: ðŸ” Type Check Backend
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install backend dependencies
        run: |
          cd backend
          npm ci

      - name: Run TypeScript compiler (type check only)
        run: |
          cd backend
          npx tsc --noEmit

  # ---------------------------------------------------------------------------
  # Frontend Type Checking
  # ---------------------------------------------------------------------------
  # Validates TypeScript types and catches type errors in frontend
  typecheck-frontend:
    name: ðŸ” Type Check Frontend
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci

      - name: Run TypeScript compiler (type check only)
        run: |
          cd frontend
          npx tsc -b --noEmit

  # ===========================================================================
  # PHASE 2: TESTING (Parallel Execution)
  # ===========================================================================
  # Comprehensive test suite ensuring functionality works as expected
  # Tests use in-memory database (no Azure dependencies required)
  # ===========================================================================

  # ---------------------------------------------------------------------------
  # Backend Tests
  # ---------------------------------------------------------------------------
  # Runs all backend unit and integration tests
  # Coverage threshold: 15%+ baseline (set in jest.config.js)
  # Current: 45 tests covering core APIs (members, activities, check-ins)
  test-backend:
    name: ðŸ§ª Test Backend
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: write # For test result annotations
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install backend dependencies
        run: |
          cd backend
          npm ci

      - name: Run backend tests with coverage
        run: |
          cd backend
          npm run test:coverage

      - name: Append coverage numbers to summary
        if: always()
        run: |
          if [ -f backend/coverage/coverage-summary.json ]; then
            node -e "const s=require('./backend/coverage/coverage-summary.json').total; const fmt=n=>n.toFixed(1)+'%'; console.log(['## Backend Coverage','',`Statements: ${fmt(s.statements.pct)}`,`Branches: ${fmt(s.branches.pct)}`,`Functions: ${fmt(s.functions.pct)}`,`Lines: ${fmt(s.lines.pct)}`].join('\n'))" >> $GITHUB_STEP_SUMMARY
          else
            echo "## Backend Coverage" >> $GITHUB_STEP_SUMMARY
            echo "Coverage summary not found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload coverage reports
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: backend-coverage
          path: backend/coverage/
          retention-days: 30

      - name: Display coverage summary
        if: always()
        run: |
          echo "## Backend Test Coverage" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f backend/coverage/lcov.info ]; then
            echo "Coverage report generated successfully âœ…" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Coverage report not found" >> $GITHUB_STEP_SUMMARY
          fi

  # ---------------------------------------------------------------------------
  # Frontend Tests
  # ---------------------------------------------------------------------------
  # Runs all frontend component and hook tests
  # Uses Vitest with React Testing Library
  # Current: 80+ tests covering core components, hooks, and pages
  test-frontend:
    name: ðŸ§ª Test Frontend
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: write # For test result annotations
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci

      - name: Run frontend tests with coverage
        run: |
          cd frontend
          npm run test:coverage

      - name: Append coverage numbers to summary
        if: always()
        run: |
          if [ -f frontend/coverage/coverage-summary.json ]; then
            node -e "const s=require('./frontend/coverage/coverage-summary.json').total; const fmt=n=>n.toFixed(1)+'%'; console.log(['## Frontend Coverage','',`Statements: ${fmt(s.statements.pct)}`,`Branches: ${fmt(s.branches.pct)}`,`Functions: ${fmt(s.functions.pct)}`,`Lines: ${fmt(s.lines.pct)}`].join('\n'))" >> $GITHUB_STEP_SUMMARY
          else
            echo "## Frontend Coverage" >> $GITHUB_STEP_SUMMARY
            echo "Coverage summary not found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload coverage reports
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: frontend-coverage
          path: frontend/coverage/
          retention-days: 30

      - name: Display coverage summary
        if: always()
        run: |
          echo "## Frontend Test Coverage" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f frontend/coverage/lcov.info ]; then
            echo "Coverage report generated successfully âœ…" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Coverage report not found" >> $GITHUB_STEP_SUMMARY
          fi

  # ===========================================================================
  # PHASE 3: BUILD
  # ===========================================================================
  # Creates production-ready build artifacts
  # Only runs if all quality checks and tests pass
  # ===========================================================================

  build:
    name: ðŸ—ï¸ Build Application
    runs-on: ubuntu-latest
    # QUALITY GATE: All quality checks and tests must pass
    needs: 
      - lint-frontend
      - typecheck-backend
      - typecheck-frontend
      - test-backend
      - test-frontend
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: |
            backend/package-lock.json
            frontend/package-lock.json

      - name: Install backend dependencies (for build only)
        run: |
          cd backend
          npm ci

      - name: Install frontend dependencies (for build only)
        run: |
          cd frontend
          npm ci

      - name: Build application
        env:
          GIT_COMMIT_SHA: ${{ github.sha }}
          GIT_COMMIT_SHORT: ${{ github.sha }}
          BUILD_TIMESTAMP: ${{ github.event.head_commit.timestamp || github.event.repository.updated_at }}
        run: |
          # Set short commit SHA (first 7 characters)
          export GIT_COMMIT_SHORT=$(echo "${{ github.sha }}" | cut -c1-7)
          
          # Export for backend (will be in compiled code)
          export GIT_COMMIT_SHA="${{ github.sha }}"
          # Use commit timestamp if available, otherwise use current time
          export BUILD_TIMESTAMP="${{ github.event.head_commit.timestamp || github.event.repository.updated_at }}"
          if [ -z "$BUILD_TIMESTAMP" ]; then
            export BUILD_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          fi
          
          # Build both frontend and backend
          npm run build
          
          # Create .env file for backend runtime
          echo "GIT_COMMIT_SHA=${{ github.sha }}" > backend/dist/.env
          echo "GIT_COMMIT_SHORT=$(echo "${{ github.sha }}" | cut -c1-7)" >> backend/dist/.env
          echo "BUILD_TIMESTAMP=${BUILD_TIMESTAMP}" >> backend/dist/.env
      
      - name: Create deployment package
        run: |
          mkdir -p deploy/backend
          mkdir -p deploy/frontend
          cp package.json deploy/
          cp -r backend/dist deploy/backend/
          cp backend/package.json deploy/backend/
          cp backend/package-lock.json deploy/backend/
          cp -r frontend/dist deploy/frontend/
          cp startup.sh deploy/ 2>/dev/null || true
          cp web.config deploy/ 2>/dev/null || true
          cd deploy && zip -r ../release.zip .

      - name: Upload deployment artifact
        uses: actions/upload-artifact@v6
        with:
          name: node-app
          path: release.zip
          retention-days: 7

  # ===========================================================================
  # PHASE 4: DEPLOYMENT
  # ===========================================================================
  # Deploys to Azure App Service
  # Only runs on main branch pushes and if all previous stages pass
  # ===========================================================================

  deploy:
    name: ðŸš€ Deploy to Azure
    runs-on: ubuntu-latest
    # QUALITY GATE: Only deploy if build succeeded
    needs: build
    # DEPLOYMENT GATE: Only deploy on main branch (not PRs)
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Download deployment artifact
        uses: actions/download-artifact@v7
        with:
          name: node-app

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_F04003FFA701477E897BF9329FCA2C5E }}
          tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_0FB429D7D41741EAA3FF70DCD8F0A441 }}
          subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_ECE14A699FEA4BB9AA978A7C54A2FE67 }}

      - name: Deploy to Azure Web App
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v3
        with:
          app-name: 'bungrfsstation'
          slot-name: 'Production'
          package: release.zip
        # Retry on 409 Conflict errors (common with Oryx builds and SCM_DO_BUILD_DURING_DEPLOYMENT)
        # These are typically transient issues caused by concurrent operations
        continue-on-error: true
      
      - name: Retry deployment if needed (handle 409 conflicts)
        if: steps.deploy-to-webapp.outcome == 'failure'
        run: |
          echo "âš ï¸  Initial deployment failed (likely 409 Conflict)"
          echo "ðŸ”„ Waiting 60 seconds before retry..."
          sleep 60
          echo "ðŸš€ Retrying deployment..."
      
      - name: Deploy to Azure Web App (Retry)
        if: steps.deploy-to-webapp.outcome == 'failure'
        uses: azure/webapps-deploy@v3
        with:
          app-name: 'bungrfsstation'
          slot-name: 'Production'
          package: release.zip

      - name: Set Azure App Service environment variables
        run: |
          # Set version environment variables in Azure App Service
          # These override any .env file values to ensure correct version reporting
          
          # Determine build timestamp with fallback (handle empty strings and null)
          BUILD_TS="${{ github.event.head_commit.timestamp }}"
          if [ -z "$BUILD_TS" ] || [ "$BUILD_TS" = "null" ]; then
            BUILD_TS="${{ github.event.repository.updated_at }}"
          fi
          if [ -z "$BUILD_TS" ] || [ "$BUILD_TS" = "null" ]; then
            BUILD_TS=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          fi
          
          az webapp config appsettings set \
            --resource-group bungrfsstation_group \
            --name bungrfsstation \
            --settings \
              GIT_COMMIT_SHA="${{ github.sha }}" \
              GIT_COMMIT_SHORT="$(echo "${{ github.sha }}" | cut -c1-7)" \
              BUILD_TIMESTAMP="$BUILD_TS" \
            --output none
          echo "âœ… Environment variables set in Azure App Service"
          echo "   - GIT_COMMIT_SHA: ${{ github.sha }}"
          echo "   - GIT_COMMIT_SHORT: $(echo "${{ github.sha }}" | cut -c1-7)"
          echo "   - BUILD_TIMESTAMP: $BUILD_TS"
          
          # Restart the app to immediately pick up new environment variables
          echo ""
          echo "ðŸ”„ Restarting Azure App Service to apply new environment variables..."
          az webapp restart \
            --resource-group bungrfsstation_group \
            --name bungrfsstation \
            --output none
          echo "âœ… App restart initiated"

      - name: Deployment summary
        run: |
          echo "## ðŸš€ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Production" >> $GITHUB_STEP_SUMMARY
          echo "- **App Name**: bungrfsstation" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # PHASE 5: POST-DEPLOYMENT TESTING
  # ===========================================================================
  # Smoke tests that validate the deployed application
  # Tests run against the live deployment with test-suffixed tables
  # Uses Azure OIDC credentials (already authenticated from deploy job)
  # ===========================================================================

  post-deployment-tests:
    name: ðŸ§ª Post-Deployment Tests
    runs-on: ubuntu-latest
    # Only run after successful deployment
    needs: deploy
    # Only run on main branch deployments
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install backend dependencies
        run: |
          cd backend
          npm ci

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_F04003FFA701477E897BF9329FCA2C5E }}
          tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_0FB429D7D41741EAA3FF70DCD8F0A441 }}
          subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_ECE14A699FEA4BB9AA978A7C54A2FE67 }}

      - name: Run post-deployment smoke tests
        env:
          APP_URL: ${{ secrets.APP_URL }}
          TABLE_STORAGE_TABLE_SUFFIX: Test
          STABILIZATION_TIMEOUT: 300
          STABILIZATION_INTERVAL: 10
          FUNCTIONAL_TEST_TIMEOUT: 120
          FUNCTIONAL_TEST_RETRIES: 2
          REQUEST_TIMEOUT: 10000
          GITHUB_SHA: ${{ github.sha }}
        run: |
          cd backend
          echo "ðŸ§ª Running two-phase post-deployment tests..."
          echo ""
          echo "Phase 1: Stabilization (up to 5 minutes)"
          echo "  - Polls until site is up AND correct version"
          echo "  - Exits immediately when ready (efficient!)"
          echo ""
          echo "Phase 2: Functional tests (minimal retries)"
          echo "  - Runs fast with 2 retries per test"
          echo "  - Expected: 30-60 seconds"
          echo ""
          echo "Target: $APP_URL"
          echo "Commit: ${{ github.sha }}"
          echo ""
          npm run test:post-deploy

      - name: Post-deployment test summary
        if: always()
        run: |
          echo "## ðŸ§ª Post-Deployment Tests" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ ${{ job.status }} == 'success' ]; then
            echo "âœ… All smoke tests passed!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The deployed application is responding correctly and all critical endpoints are functional." >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Some smoke tests failed!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the test output above for details. The deployment may have issues." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Target URL**: ${{ secrets.APP_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Test Environment**: TABLE_STORAGE_TABLE_SUFFIX=Test" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
