# Brigade Data Separation Traceability Audit

**Audit Date:** February 7, 2026  
**Auditor:** GitHub Copilot (AI Agent)  
**Scope:** Full system review of brigade data separation and context handling  
**Status:** ‚ö†Ô∏è CRITICAL VULNERABILITIES FOUND

---

## Executive Summary

This audit identified **CRITICAL cross-brigade data contamination vulnerabilities** in the RFS Station Manager system. The primary issue is that WebSocket real-time updates are broadcast globally to all connected clients regardless of their brigade/station context, enabling users from Brigade A to see real-time data from Brigade B.

**Impact:**
- üö® **Data Privacy Violation:** Cross-brigade visibility of member check-ins, events, activities
- üö® **Operational Security Risk:** Unauthorized access to operational data
- üö® **Compliance Risk:** Potential breach of organizational data separation policies

**Immediate Action Required:**
- Implement Socket.io room-based filtering for all real-time events
- Add station context to all cache keys in offline storage
- Validate and test cross-brigade isolation

---

## Methodology

### Audit Approach

1. **Context Analysis:** Reviewed how brigade/station context is stored and propagated
2. **Code Review:** Examined all API endpoints, database queries, and WebSocket handlers
3. **Data Flow Tracing:** Mapped data flow from frontend ‚Üí API ‚Üí database ‚Üí WebSocket
4. **Threat Modeling:** Identified attack vectors for cross-brigade data access

### Tools Used
- Static code analysis (grep, pattern matching)
- TypeScript type system analysis
- Architecture review of Socket.io implementation
- Review of offline storage mechanisms (IndexedDB)

### Files Audited
- ‚úÖ Backend: `src/index.ts`, `src/routes/*.ts`, `src/services/*.ts`
- ‚úÖ Frontend: `src/hooks/useSocket.ts`, `src/services/offlineStorage.ts`, `src/contexts/StationContext.tsx`
- ‚úÖ Types: `src/types/index.ts` (backend and frontend)

---

## Findings

### 1. üö® CRITICAL: Global WebSocket Broadcasts (CVE-CANDIDATE)

**Severity:** CRITICAL (10/10)  
**Status:** CONFIRMED VULNERABILITY  
**Impact:** Cross-brigade data visibility in real-time

#### Description

All WebSocket events use `io.emit()` or `socket.broadcast.emit()`, which broadcasts to **every connected client** regardless of their station/brigade context. This violates data separation principles and enables unauthorized cross-brigade data access.

#### Affected Code

**File:** `/backend/src/index.ts` (lines 235-280)

```typescript
// ‚ùå VULNERABLE: Broadcasts to ALL clients globally
socket.on('checkin', (data) => {
  socket.broadcast.emit('checkin-update', data);  // Line 247
});

socket.on('activity-change', (data) => {
  io.emit('activity-update', data);  // Line 254
});

socket.on('member-added', (data) => {
  socket.broadcast.emit('member-update', data);  // Line 260
});

socket.on('event-created', (data) => {
  io.emit('event-update', data);  // Line 266
});

socket.on('event-ended', (data) => {
  io.emit('event-update', data);  // Line 272
});

socket.on('participant-change', (data) => {
  io.emit('event-update', data);  // Line 278
});
```

**File:** `/backend/src/routes/truckChecks.ts` (lines 239, 253, 342, 393)

```typescript
// ‚ùå VULNERABLE: Truck check updates broadcast globally
io.emit('truck-check-update', {
  type: 'contributor-joined',
  runId: checkRun!.id,
  contributorName: completedByName || completedBy,
  checkRun,
  timestamp: new Date()
});
```

**File:** `/backend/src/routes/stations.ts` (lines 283, 326, 369, 450)

```typescript
// ‚ùå VULNERABLE: Station management broadcast globally
io.emit('station-created', newStation);
io.emit('station-updated', updatedStation);
io.emit('station-deleted', { stationId: id });
io.emit('demo-station-reset', { stationId: DEMO_STATION_ID });
```

#### Steps to Reproduce

**Prerequisites:**
- Two browser windows/tabs
- User A logged into Station A (Brigade 1)
- User B logged into Station B (Brigade 2)

**Test Case 1: Cross-Brigade Check-In Visibility**

1. Open Browser A ‚Üí Sign in to Station A (Brigade 1)
2. Open Browser B ‚Üí Sign in to Station B (Brigade 2)
3. In Browser A ‚Üí Perform a member check-in
4. **BUG:** Browser B receives `checkin-update` WebSocket event
5. **EXPECTED:** Browser B should NOT receive any update

**Test Case 2: Cross-Brigade Event Creation**

1. Open Browser A ‚Üí Sign in to Station A (Brigade 1)
2. Open Browser B ‚Üí Sign in to Station B (Brigade 2)
3. In Browser A ‚Üí Create a new event (training, callout, etc.)
4. **BUG:** Browser B receives `event-update` WebSocket event
5. **EXPECTED:** Browser B should NOT receive any update

**Test Case 3: Cross-Brigade Activity Changes**

1. Open Browser A ‚Üí Sign in to Station A (Brigade 1)
2. Open Browser B ‚Üí Sign in to Station B (Brigade 2)
3. In Browser A ‚Üí Change active activity
4. **BUG:** Browser B receives `activity-update` WebSocket event
5. **EXPECTED:** Browser B should NOT receive any update

**Test Case 4: Cross-Brigade Truck Check Updates**

1. Open Browser A ‚Üí Sign in to Station A (Brigade 1)
2. Open Browser B ‚Üí Sign in to Station B (Brigade 2)
3. In Browser A ‚Üí Start a truck check
4. **BUG:** Browser B receives `truck-check-update` WebSocket event
5. **EXPECTED:** Browser B should NOT receive any update

#### Proof of Concept

```bash
# Terminal 1: Monitor WebSocket events for Station A
curl -X GET http://localhost:3000/api/stations | jq '.[] | select(.name == "Station A")'
# Note the stationId

# Terminal 2: Monitor WebSocket events for Station B
curl -X GET http://localhost:3000/api/stations | jq '.[] | select(.name == "Station B")'
# Note the stationId

# Browser Console (Station A):
const socket = io('http://localhost:3000');
socket.on('event-update', (data) => {
  console.log('Station A received event:', data);
});

# Browser Console (Station B):
const socket = io('http://localhost:3000');
socket.on('event-update', (data) => {
  console.log('Station B received event:', data);  // ‚ùå Should NOT receive
});

# Trigger event from Station A
# ‚Üí Both consoles log the event (VULNERABILITY CONFIRMED)
```

#### Root Cause

Socket.io connections are not scoped to rooms based on `stationId` or `brigadeId`. All clients are in the global namespace, so any broadcast reaches everyone.

**Current Architecture:**
```
Client A (Station A) ‚îÄ‚îÄ‚îê
                        ‚îú‚îÄ‚Üí Global Socket.io Namespace (ALL CLIENTS)
Client B (Station B) ‚îÄ‚îÄ‚îò
```

**Missing:** Room-based isolation:
```
Client A (Station A) ‚îÄ‚îÄ‚Üí Room "station-A" ‚îÄ‚îÄ‚Üí Only receives Station A events
Client B (Station B) ‚îÄ‚îÄ‚Üí Room "station-B" ‚îÄ‚îÄ‚Üí Only receives Station B events
```

#### Impact Assessment

| Area | Impact | Severity |
|------|--------|----------|
| **Data Privacy** | Cross-brigade visibility of PII (member names, check-ins) | CRITICAL |
| **Operational Security** | Unauthorized access to operational status | HIGH |
| **Audit Trail** | Difficult to trace who saw what data | HIGH |
| **User Trust** | Undermines confidence in system isolation | CRITICAL |
| **Compliance** | Potential breach of data separation policies | CRITICAL |

#### Affected Events

All WebSocket events are vulnerable:

| Event Name | Trigger | Exposed Data |
|------------|---------|--------------|
| `checkin-update` | Member check-in/out | Member ID, name, timestamp, activity |
| `activity-update` | Activity change | Activity details, station status |
| `member-update` | New member added | Full member record (name, phone, roles) |
| `event-update` | Event created/ended/participant change | Event details, participants |
| `truck-check-update` | Truck check progress | Appliance details, checklist results |
| `station-created` | Station created | Full station details |
| `station-updated` | Station updated | Updated station details |
| `station-deleted` | Station deleted | Station ID |
| `demo-station-reset` | Demo reset | Demo station ID |

---

### 2. ‚ö†Ô∏è HIGH: Offline Cache Missing Station Context

**Severity:** HIGH (8/10)  
**Status:** CONFIRMED VULNERABILITY  
**Impact:** Cross-brigade data persistence in offline mode

#### Description

IndexedDB cache keys in `offlineStorage.ts` do not include `stationId`, causing cached data from one brigade to persist when a user switches to another brigade. In offline mode, this results in showing Brigade A's data when the user is actually viewing Brigade B.

#### Affected Code

**File:** `/frontend/src/services/offlineStorage.ts` (lines 130-150)

```typescript
// ‚ùå VULNERABLE: Cache key lacks station context
export async function cacheData(key: string, data: unknown, expiresInMs?: number): Promise<void> {
  const database = await initDB();
  const cachedData: CachedData = {
    key,  // ‚ùå No stationId in key
    data,
    timestamp: Date.now(),
    expiresAt: expiresInMs ? Date.now() + expiresInMs : undefined,
  };
  await database.put('cached-data', cachedData);
}

export async function getCachedData(key: string): Promise<unknown | null> {
  const database = await initDB();
  const cached = await database.get('cached-data', key);  // ‚ùå No station validation
  
  if (!cached) return null;
  
  // Check expiration
  if (cached.expiresAt && Date.now() > cached.expiresAt) {
    await database.delete('cached-data', key);
    return null;
  }
  
  return cached.data;
}
```

#### Steps to Reproduce

**Prerequisites:**
- Browser with DevTools
- Two stations configured (Station A in Brigade 1, Station B in Brigade 2)

**Test Case: Offline Data Contamination**

1. Open browser ‚Üí Sign in to Station A (Brigade 1)
2. Load members page ‚Üí Data cached to IndexedDB as key `members`
3. Open DevTools ‚Üí Application ‚Üí IndexedDB ‚Üí `station-manager-db` ‚Üí `cached-data`
4. Verify cached entry with key `members` contains Station A's members
5. Switch station ‚Üí Select Station B (Brigade 2)
6. **Disconnect from network** (DevTools ‚Üí Network ‚Üí Offline)
7. Refresh members page
8. **BUG:** Page shows Station A's members (cached) even though context is Station B
9. **EXPECTED:** Should show empty state or "no offline data for this station"

**Test Case: Cache Key Collision**

1. Sign in to Station A ‚Üí Cache `members` key with 10 members
2. Sign in to Station B ‚Üí Cache `members` key with 15 members (overwrites Station A)
3. Switch back to Station A ‚Üí Go offline
4. **BUG:** Shows Station B's 15 members instead of Station A's 10
5. **EXPECTED:** Each station should have isolated cache keys

#### Root Cause

Cache keys are station-agnostic:
```typescript
// Current (WRONG):
cacheData('members', membersData);         // ‚ùå No station context
cacheData('events', eventsData);           // ‚ùå No station context
cacheData('activities', activitiesData);   // ‚ùå No station context

// Should be:
cacheData('station-123:members', membersData);      // ‚úÖ Station-scoped
cacheData('station-456:events', eventsData);        // ‚úÖ Station-scoped
cacheData('station-123:activities', activitiesData); // ‚úÖ Station-scoped
```

#### Impact Assessment

| Area | Impact | Severity |
|------|--------|----------|
| **Offline Mode** | Wrong brigade data displayed | HIGH |
| **Data Integrity** | Cache overwriting between brigades | HIGH |
| **User Experience** | Confusing/incorrect data in offline mode | MEDIUM |
| **Audit Trail** | Cache doesn't track which station's data | MEDIUM |

---

### 3. ‚ö†Ô∏è HIGH: Truck Check Broadcasts Lack Station Filtering

**Severity:** HIGH (7/10)  
**Status:** CONFIRMED VULNERABILITY  
**Impact:** Cross-brigade visibility of vehicle maintenance checks

#### Description

While truck check data includes `stationId`, the WebSocket broadcasts use global `io.emit()`, meaning all clients receive truck check updates regardless of their brigade. This is especially concerning for operational security as vehicle readiness is sensitive information.

#### Affected Code

**File:** `/backend/src/routes/truckChecks.ts` (lines 239-259, 342-360, 393-410)

```typescript
// ‚ùå VULNERABLE: Global broadcast of truck check updates
io.emit('truck-check-update', {
  type: 'contributor-joined',
  runId: checkRun!.id,
  contributorName: completedByName || completedBy,
  checkRun,  // Contains stationId but broadcast is global
  timestamp: new Date()
});

io.emit('truck-check-update', {
  type: 'question-answered',
  runId: id,
  questionId: question_id,
  result,
  checkRun: updatedCheckRun
});

io.emit('truck-check-update', {
  type: 'check-completed',
  runId: id,
  checkRun: completedCheckRun,
  timestamp: new Date()
});
```

#### Steps to Reproduce

**Test Case: Cross-Brigade Truck Check Visibility**

1. Open Browser A ‚Üí Sign in to Station A (Brigade 1)
2. Open Browser B ‚Üí Sign in to Station B (Brigade 2)
3. In Browser A ‚Üí Start a truck check for Appliance 1
4. In Browser A ‚Üí Answer several checklist questions
5. **BUG:** Browser B receives all `truck-check-update` events
6. Open DevTools Console in Browser B ‚Üí See truck check updates logged
7. **EXPECTED:** Browser B should receive no updates

#### Impact Assessment

| Area | Impact | Severity |
|------|--------|----------|
| **Operational Security** | Cross-brigade visibility of vehicle readiness | HIGH |
| **Data Privacy** | Contributor names visible across brigades | MEDIUM |
| **Audit Trail** | Difficult to determine authorized viewers | MEDIUM |

---

### 4. üìã MEDIUM: Station Management Broadcasts to All Clients

**Severity:** MEDIUM (5/10)  
**Status:** CONFIRMED ISSUE  
**Impact:** Information disclosure of station management operations

#### Description

Station CRUD operations (create, update, delete) broadcast to all connected clients. While station data may be intended to be globally visible for administrative purposes, this could enable unauthorized awareness of station management activities.

#### Affected Code

**File:** `/backend/src/routes/stations.ts` (lines 283, 326, 369, 450)

```typescript
// Station creation
io.emit('station-created', newStation);

// Station update
io.emit('station-updated', updatedStation);

// Station deletion
io.emit('station-deleted', { stationId: id });

// Demo station reset
io.emit('demo-station-reset', { stationId: DEMO_STATION_ID });
```

#### Recommendation

Consider whether these events should be:
- **Option A:** Admin-only (emit to admin clients only)
- **Option B:** Brigade-scoped (emit to brigade members only)
- **Option C:** Global (current behavior, if intended)

---

### 5. üìã MEDIUM: Offline Queue Missing Station Context Validation

**Severity:** MEDIUM (5/10)  
**Status:** POTENTIAL ISSUE  
**Impact:** Queued actions may execute with wrong station context

#### Description

The offline queue stores actions without explicitly embedding `stationId` in the queue item structure. If a user switches stations while offline, queued actions may execute with the wrong station context when coming back online.

#### Affected Code

**File:** `/frontend/src/services/offlineStorage.ts` (lines 18-28)

```typescript
export interface QueuedAction {
  id: string;
  type: 'checkin' | 'checkout' | 'create-member' | 'create-event' | 'end-event' | 'update-activity' | 'other';
  endpoint: string;
  method: 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  data: unknown;  // ‚ùå May or may not include stationId
  timestamp: number;
  retryCount: number;
  status: 'pending' | 'syncing' | 'failed' | 'synced';
  error?: string;
  // Missing: stationId field for context validation
}
```

#### Steps to Reproduce

**Test Case: Station Switch During Offline Queue**

1. Sign in to Station A ‚Üí Go offline
2. Perform action (e.g., check-in member) ‚Üí Queued
3. Switch to Station B (still offline)
4. Perform action (e.g., create event) ‚Üí Queued
5. Come back online ‚Üí Queue processes
6. **POTENTIAL BUG:** Action from step 2 might execute with Station B context
7. **EXPECTED:** Each action should remember its original station context

#### Mitigation

Currently, the API service (`services/api.ts`) includes `X-Station-Id` header in all requests. If the offline queue preserves the full `endpoint` string with headers, this may be mitigated. Further investigation required.

---

### 6. üìã LOW: Global Active Activity State (Design Risk)

**Severity:** LOW (3/10)  
**Status:** POTENTIAL DESIGN ISSUE (MITIGATED)  
**Impact:** Theoretical risk of cross-station activity state mixing

#### Description

The in-memory database service stores a single global `activeActivity` object:

```typescript
private activeActivity: ActiveActivity | null = null;
```

If not properly filtered by middleware, multiple stations could theoretically share the same active activity state.

#### Current Mitigation

The code uses `getEffectiveStationId()` middleware to filter queries by station. As long as this middleware is applied correctly to all endpoints, the risk is mitigated.

#### Recommendation

Monitor for any cases where active activity queries bypass the station filter middleware.

---

## Architecture Review

### Current WebSocket Architecture (VULNERABLE)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Socket.io Server                              ‚îÇ
‚îÇ                  (Global Namespace)                              ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îÇ  All clients connected to same namespace                         ‚îÇ
‚îÇ  No room-based isolation                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                    ‚îÇ                    ‚îÇ
         ‚îÇ io.emit()         ‚îÇ io.emit()          ‚îÇ io.emit()
         ‚Üì                    ‚Üì                    ‚Üì
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Client A ‚îÇ         ‚îÇ Client B ‚îÇ         ‚îÇ Client C ‚îÇ
   ‚îÇStation A ‚îÇ         ‚îÇStation B ‚îÇ         ‚îÇStation C ‚îÇ
   ‚îÇBrigade 1 ‚îÇ         ‚îÇBrigade 2 ‚îÇ         ‚îÇBrigade 1 ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   
   ‚ùå All clients receive ALL events regardless of brigade/station
```

### Recommended WebSocket Architecture (SECURE)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Socket.io Server                              ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
‚îÇ  ‚îÇRoom:         ‚îÇ  ‚îÇRoom:         ‚îÇ  ‚îÇRoom:         ‚îÇ         ‚îÇ
‚îÇ  ‚îÇstation-A     ‚îÇ  ‚îÇstation-B     ‚îÇ  ‚îÇstation-C     ‚îÇ         ‚îÇ
‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ         ‚îÇ
‚îÇ  ‚îÇ[Client A]    ‚îÇ  ‚îÇ[Client B]    ‚îÇ  ‚îÇ[Client C]    ‚îÇ         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
‚îÇ  ‚îÇRoom:         ‚îÇ  ‚îÇRoom:         ‚îÇ                            ‚îÇ
‚îÇ  ‚îÇbrigade-1     ‚îÇ  ‚îÇbrigade-2     ‚îÇ                            ‚îÇ
‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ                            ‚îÇ
‚îÇ  ‚îÇ[Client A]    ‚îÇ  ‚îÇ[Client B]    ‚îÇ                            ‚îÇ
‚îÇ  ‚îÇ[Client C]    ‚îÇ  ‚îÇ              ‚îÇ                            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                    ‚îÇ                    ‚îÇ
         ‚îÇ to(station-A)     ‚îÇ to(station-B)     ‚îÇ to(brigade-1)
         ‚Üì                    ‚Üì                    ‚Üì
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Client A ‚îÇ         ‚îÇ Client B ‚îÇ         ‚îÇ Client C ‚îÇ
   ‚îÇStation A ‚îÇ         ‚îÇStation B ‚îÇ         ‚îÇStation C ‚îÇ
   ‚îÇBrigade 1 ‚îÇ         ‚îÇBrigade 2 ‚îÇ         ‚îÇBrigade 1 ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   
   ‚úÖ Clients only receive events for their station/brigade rooms
```

### Current Offline Storage (VULNERABLE)

```
IndexedDB: station-manager-db
‚îú‚îÄ‚îÄ cached-data
‚îÇ   ‚îú‚îÄ‚îÄ key: "members"        ‚Üê ‚ùå No station context
‚îÇ   ‚îú‚îÄ‚îÄ key: "events"         ‚Üê ‚ùå No station context
‚îÇ   ‚îî‚îÄ‚îÄ key: "activities"     ‚Üê ‚ùå No station context
‚îî‚îÄ‚îÄ offline-queue
    ‚îî‚îÄ‚îÄ actions[]             ‚Üê ‚ùå No station validation
```

### Recommended Offline Storage (SECURE)

```
IndexedDB: station-manager-db
‚îú‚îÄ‚îÄ cached-data
‚îÇ   ‚îú‚îÄ‚îÄ key: "station-123:members"     ‚Üê ‚úÖ Station-scoped
‚îÇ   ‚îú‚îÄ‚îÄ key: "station-456:events"      ‚Üê ‚úÖ Station-scoped
‚îÇ   ‚îî‚îÄ‚îÄ key: "station-123:activities"  ‚Üê ‚úÖ Station-scoped
‚îî‚îÄ‚îÄ offline-queue
    ‚îî‚îÄ‚îÄ actions[] with stationId field ‚Üê ‚úÖ Context preserved
```

---

## Remediation Plan

### Priority 1: CRITICAL (Fix Immediately)

#### Fix 1.1: Implement Socket.io Room-Based Filtering

**Objective:** Ensure WebSocket events only reach clients in the correct station/brigade

**Changes Required:**

1. **Backend: Client Connection & Room Assignment**

File: `/backend/src/index.ts`

```typescript
// Add near top of file
interface SocketWithStation extends Socket {
  stationId?: string;
  brigadeId?: string;
}

// Modify connection handler
io.on('connection', (socket: SocketWithStation) => {
  logger.info('WebSocket client connected', { socketId: socket.id });

  // NEW: Client must send 'join-station' event with stationId
  socket.on('join-station', (data: { stationId: string; brigadeId?: string }) => {
    const { stationId, brigadeId } = data;
    
    // Validate stationId exists
    // TODO: Add database lookup to verify station exists
    
    // Store on socket instance
    socket.stationId = stationId;
    socket.brigadeId = brigadeId;
    
    // Join station-specific room
    socket.join(`station-${stationId}`);
    
    // Join brigade-specific room if provided
    if (brigadeId) {
      socket.join(`brigade-${brigadeId}`);
    }
    
    logger.info('Client joined station room', { 
      socketId: socket.id, 
      stationId, 
      brigadeId 
    });
    
    // Acknowledge join
    socket.emit('joined-station', { stationId, brigadeId });
  });

  socket.on('disconnect', () => {
    logger.info('WebSocket client disconnected', { 
      socketId: socket.id,
      stationId: socket.stationId,
      brigadeId: socket.brigadeId
    });
  });

  // UPDATED: Station-scoped broadcasts
  socket.on('checkin', (data) => {
    logger.debug('WebSocket event: checkin', { data, stationId: socket.stationId });
    
    // Validate socket has joined a station
    if (!socket.stationId) {
      logger.warn('Socket attempted checkin without joining station', { socketId: socket.id });
      return;
    }
    
    // Broadcast only to same station
    io.to(`station-${socket.stationId}`).emit('checkin-update', data);
  });

  socket.on('activity-change', (data) => {
    logger.debug('WebSocket event: activity-change', { data, stationId: socket.stationId });
    
    if (!socket.stationId) return;
    
    // Broadcast only to same station
    io.to(`station-${socket.stationId}`).emit('activity-update', data);
  });

  socket.on('member-added', (data) => {
    logger.debug('WebSocket event: member-added', { data, stationId: socket.stationId });
    
    if (!socket.stationId) return;
    
    // Broadcast only to same station
    io.to(`station-${socket.stationId}`).emit('member-update', data);
  });

  socket.on('event-created', (data) => {
    logger.debug('WebSocket event: event-created', { data, stationId: socket.stationId });
    
    if (!socket.stationId) return;
    
    // Broadcast only to same station
    io.to(`station-${socket.stationId}`).emit('event-update', data);
  });

  socket.on('event-ended', (data) => {
    logger.debug('WebSocket event: event-ended', { data, stationId: socket.stationId });
    
    if (!socket.stationId) return;
    
    // Broadcast only to same station
    io.to(`station-${socket.stationId}`).emit('event-update', data);
  });

  socket.on('participant-change', (data) => {
    logger.debug('WebSocket event: participant-change', { data, stationId: socket.stationId });
    
    if (!socket.stationId) return;
    
    // Broadcast only to same station
    io.to(`station-${socket.stationId}`).emit('event-update', data);
  });
});
```

2. **Backend: Update Route Broadcasts**

File: `/backend/src/routes/truckChecks.ts`

```typescript
// Find all instances of io.emit('truck-check-update', ...)
// Replace with:
io.to(`station-${checkRun.stationId}`).emit('truck-check-update', {
  type: 'contributor-joined',
  runId: checkRun!.id,
  contributorName: completedByName || completedBy,
  checkRun,
  timestamp: new Date()
});

// Repeat for all truck-check-update broadcasts
```

File: `/backend/src/routes/stations.ts`

```typescript
// Station creation - decide on broadcast strategy:
// Option A: Admin-only (requires admin room)
// Option B: Brigade-scoped
// Option C: Global (if intentional)

// Example for brigade-scoped:
io.to(`brigade-${newStation.brigadeId}`).emit('station-created', newStation);
io.to(`brigade-${updatedStation.brigadeId}`).emit('station-updated', updatedStation);
io.to(`brigade-${station.brigadeId}`).emit('station-deleted', { stationId: id });
```

3. **Frontend: Join Station Room on Connection**

File: `/frontend/src/hooks/useSocket.ts`

```typescript
import { useEffect, useRef, useState } from 'react';
import { io, Socket } from 'socket.io-client';
import { useStation } from '../contexts/StationContext';

// Use current location in production, localhost in development
const SOCKET_URL = import.meta.env.VITE_SOCKET_URL || 
  (import.meta.env.PROD ? window.location.origin : 'http://localhost:3000');

export function useSocket() {
  const socketRef = useRef<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const { selectedStation } = useStation();

  useEffect(() => {
    // Initialize socket connection
    socketRef.current = io(SOCKET_URL, {
      transports: ['websocket'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: Infinity,
    });

    const socket = socketRef.current;

    socket.on('connect', () => {
      console.log('Socket connected');
      setIsConnected(true);
      
      // NEW: Join station room if station is selected
      if (selectedStation) {
        socket.emit('join-station', {
          stationId: selectedStation.id,
          brigadeId: selectedStation.brigadeId
        });
      }
    });

    socket.on('disconnect', () => {
      console.log('Socket disconnected');
      setIsConnected(false);
    });

    socket.on('joined-station', (data) => {
      console.log('Joined station room:', data);
    });

    return () => {
      socket.disconnect();
    };
  }, []);

  // NEW: Re-join when station changes
  useEffect(() => {
    if (socketRef.current && isConnected && selectedStation) {
      socketRef.current.emit('join-station', {
        stationId: selectedStation.id,
        brigadeId: selectedStation.brigadeId
      });
    }
  }, [selectedStation, isConnected]);

  const emit = (event: string, data: unknown) => {
    if (socketRef.current) {
      socketRef.current.emit(event, data);
    }
  };

  const on = <T = unknown>(event: string, callback: (data: T) => void) => {
    if (socketRef.current) {
      socketRef.current.on(event, callback as (data: unknown) => void);
    }
  };

  const off = <T = unknown>(event: string, callback?: (data: T) => void) => {
    if (socketRef.current) {
      socketRef.current.off(event, callback as ((data: unknown) => void) | undefined);
    }
  };

  return {
    isConnected,
    emit,
    on,
    off,
  };
}
```

**Testing:**
- Manual testing with multiple browser windows/stations
- Verify `io.to()` calls with Socket.io admin UI
- Unit tests for room joining logic

**Estimated Effort:** 4-6 hours  
**Risk:** Medium (could break existing functionality if not tested thoroughly)

---

#### Fix 1.2: Add Station Context to Offline Cache

**Objective:** Prevent cross-brigade data contamination in offline mode

**Changes Required:**

File: `/frontend/src/services/offlineStorage.ts`

```typescript
// Add helper to get current station ID from context
// (Requires importing StationContext or reading from localStorage)
function getCurrentStationId(): string | null {
  // Read from localStorage where StationContext persists it
  const savedStationId = localStorage.getItem('selectedStationId');
  return savedStationId;
}

// Update cacheData to include station context
export async function cacheData(key: string, data: unknown, expiresInMs?: number): Promise<void> {
  const database = await initDB();
  const stationId = getCurrentStationId();
  
  // ‚úÖ Prefix key with station context
  const scopedKey = stationId ? `station-${stationId}:${key}` : key;
  
  const cachedData: CachedData = {
    key: scopedKey,
    data,
    timestamp: Date.now(),
    expiresAt: expiresInMs ? Date.now() + expiresInMs : undefined,
  };
  await database.put('cached-data', cachedData);
  console.log('[OfflineStorage] Cached data:', { scopedKey, stationId });
}

// Update getCachedData to use station context
export async function getCachedData(key: string): Promise<unknown | null> {
  const database = await initDB();
  const stationId = getCurrentStationId();
  
  // ‚úÖ Use scoped key for lookup
  const scopedKey = stationId ? `station-${stationId}:${key}` : key;
  const cached = await database.get('cached-data', scopedKey);
  
  if (!cached) return null;
  
  // Check expiration
  if (cached.expiresAt && Date.now() > cached.expiresAt) {
    await database.delete('cached-data', scopedKey);
    return null;
  }
  
  console.log('[OfflineStorage] Retrieved cached data:', { scopedKey, stationId });
  return cached.data;
}

// Add clearCacheForStation to clean up when switching
export async function clearCacheForStation(stationId: string): Promise<void> {
  const database = await initDB();
  const allCached = await database.getAll('cached-data');
  
  const stationPrefix = `station-${stationId}:`;
  for (const item of allCached) {
    if (item.key.startsWith(stationPrefix)) {
      await database.delete('cached-data', item.key);
    }
  }
  console.log('[OfflineStorage] Cleared cache for station:', stationId);
}
```

**Update QueuedAction interface to include stationId:**

```typescript
export interface QueuedAction {
  id: string;
  type: 'checkin' | 'checkout' | 'create-member' | 'create-event' | 'end-event' | 'update-activity' | 'other';
  endpoint: string;
  method: 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  data: unknown;
  timestamp: number;
  retryCount: number;
  status: 'pending' | 'syncing' | 'failed' | 'synced';
  error?: string;
  stationId: string;  // ‚úÖ NEW: Preserve station context
}

// Update addToQueue to capture stationId
export async function addToQueue(action: Omit<QueuedAction, 'id' | 'timestamp' | 'retryCount' | 'status' | 'stationId'>): Promise<string> {
  const database = await initDB();
  const id = `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
  const stationId = getCurrentStationId();
  
  if (!stationId) {
    throw new Error('Cannot queue action without station context');
  }
  
  const queuedAction: QueuedAction = {
    ...action,
    id,
    timestamp: Date.now(),
    retryCount: 0,
    status: 'pending',
    stationId,  // ‚úÖ NEW: Store station context
  };

  await database.add('offline-queue', queuedAction);
  console.log('[OfflineQueue] Added to queue:', queuedAction);
  
  return id;
}
```

**Testing:**
- Switch stations and verify cache isolation
- Test offline mode with station switching
- Verify queue actions preserve station context

**Estimated Effort:** 2-3 hours  
**Risk:** Low (mostly additive changes)

---

### Priority 2: HIGH (Fix Within 1 Week)

#### Fix 2.1: Add Validation Tests for Brigade Isolation

**Objective:** Automated tests to detect cross-brigade data leaks

**Test Cases:**

1. **Integration Test: WebSocket Room Isolation**

File: `/backend/src/__tests__/websocket-isolation.test.ts` (NEW)

```typescript
import { io, Socket } from 'socket.io-client';
import { startTestServer, stopTestServer } from './testHelpers';

describe('WebSocket Brigade Isolation', () => {
  let serverUrl: string;
  let clientA: Socket;
  let clientB: Socket;

  beforeAll(async () => {
    serverUrl = await startTestServer();
  });

  afterAll(async () => {
    await stopTestServer();
  });

  beforeEach((done) => {
    clientA = io(serverUrl);
    clientB = io(serverUrl);
    
    let connectedCount = 0;
    const checkDone = () => {
      connectedCount++;
      if (connectedCount === 2) done();
    };
    
    clientA.on('connect', checkDone);
    clientB.on('connect', checkDone);
  });

  afterEach(() => {
    clientA.disconnect();
    clientB.disconnect();
  });

  it('should not broadcast check-in to different station', (done) => {
    // Client A joins station-1
    clientA.emit('join-station', { stationId: 'station-1', brigadeId: 'brigade-1' });
    
    // Client B joins station-2
    clientB.emit('join-station', { stationId: 'station-2', brigadeId: 'brigade-2' });
    
    // Client B should NOT receive checkin-update
    clientB.on('checkin-update', () => {
      done(new Error('Client B received checkin-update from Client A'));
    });
    
    // Client A emits checkin
    setTimeout(() => {
      clientA.emit('checkin', { memberId: 'member-1', stationId: 'station-1' });
    }, 100);
    
    // Wait to ensure no event received
    setTimeout(() => {
      done();
    }, 500);
  });

  it('should broadcast events to same station only', (done) => {
    const stationId = 'test-station-123';
    
    // Both clients join same station
    clientA.emit('join-station', { stationId, brigadeId: 'brigade-1' });
    clientB.emit('join-station', { stationId, brigadeId: 'brigade-1' });
    
    // Client B should receive event-update
    clientB.on('event-update', (data) => {
      expect(data.eventId).toBe('event-1');
      done();
    });
    
    // Client A creates event
    setTimeout(() => {
      clientA.emit('event-created', { eventId: 'event-1', stationId });
    }, 100);
  });

  it('should allow brigade-level broadcasts', (done) => {
    const brigadeId = 'brigade-1';
    
    // Both clients in same brigade, different stations
    clientA.emit('join-station', { stationId: 'station-1', brigadeId });
    clientB.emit('join-station', { stationId: 'station-2', brigadeId });
    
    // For brigade-wide events (if implemented)
    // Test that both receive brigade-level updates
    done();
  });
});
```

2. **Frontend Test: Offline Cache Isolation**

File: `/frontend/src/services/__tests__/offlineStorage.test.ts` (NEW)

```typescript
import { cacheData, getCachedData, clearCacheForStation } from '../offlineStorage';

describe('Offline Storage Brigade Isolation', () => {
  beforeEach(async () => {
    // Clear all cached data
    const db = await initDB();
    await db.clear('cached-data');
  });

  it('should isolate cache by station', async () => {
    // Mock station context for station-1
    localStorage.setItem('selectedStationId', 'station-1');
    await cacheData('members', [{ id: 1, name: 'Member A' }]);
    
    // Mock station context for station-2
    localStorage.setItem('selectedStationId', 'station-2');
    await cacheData('members', [{ id: 2, name: 'Member B' }]);
    
    // Retrieve for station-1
    localStorage.setItem('selectedStationId', 'station-1');
    const membersA = await getCachedData('members');
    expect(membersA).toEqual([{ id: 1, name: 'Member A' }]);
    
    // Retrieve for station-2
    localStorage.setItem('selectedStationId', 'station-2');
    const membersB = await getCachedData('members');
    expect(membersB).toEqual([{ id: 2, name: 'Member B' }]);
  });

  it('should clear cache for specific station', async () => {
    localStorage.setItem('selectedStationId', 'station-1');
    await cacheData('members', [{ id: 1 }]);
    await cacheData('events', [{ id: 1 }]);
    
    await clearCacheForStation('station-1');
    
    const members = await getCachedData('members');
    const events = await getCachedData('events');
    
    expect(members).toBeNull();
    expect(events).toBeNull();
  });
});
```

**Estimated Effort:** 3-4 hours  
**Risk:** Low (test infrastructure already exists)

---

#### Fix 2.2: Add Admin Dashboard for Brigade Isolation Monitoring

**Objective:** Real-time monitoring of WebSocket connections and room assignments

**Implementation:**

File: `/backend/src/routes/admin.ts` (NEW)

```typescript
import { Router } from 'express';

const router = Router();

// GET /api/admin/socket-status
router.get('/socket-status', (req, res) => {
  const io = req.app.get('io');
  
  const sockets = io.sockets.sockets;
  const connections = Array.from(sockets.values()).map((socket: any) => ({
    id: socket.id,
    stationId: socket.stationId,
    brigadeId: socket.brigadeId,
    rooms: Array.from(socket.rooms),
    connected: socket.connected,
  }));
  
  // Group by station
  const byStation = connections.reduce((acc, conn) => {
    const station = conn.stationId || 'unassigned';
    if (!acc[station]) acc[station] = [];
    acc[station].push(conn);
    return acc;
  }, {} as Record<string, typeof connections>);
  
  res.json({
    totalConnections: connections.length,
    byStation,
    connections,
  });
});

export default router;
```

**Frontend Admin Page:**

File: `/frontend/src/features/admin/SocketMonitorPage.tsx` (NEW)

```tsx
import React, { useEffect, useState } from 'react';
import api from '../../services/api';

interface SocketConnection {
  id: string;
  stationId?: string;
  brigadeId?: string;
  rooms: string[];
  connected: boolean;
}

interface SocketStatus {
  totalConnections: number;
  byStation: Record<string, SocketConnection[]>;
  connections: SocketConnection[];
}

export function SocketMonitorPage() {
  const [status, setStatus] = useState<SocketStatus | null>(null);

  useEffect(() => {
    const fetchStatus = async () => {
      const data = await api.get('/api/admin/socket-status');
      setStatus(data);
    };

    fetchStatus();
    const interval = setInterval(fetchStatus, 5000);
    return () => clearInterval(interval);
  }, []);

  if (!status) return <div>Loading...</div>;

  return (
    <div className="socket-monitor">
      <h1>WebSocket Connection Monitor</h1>
      <p>Total Connections: {status.totalConnections}</p>
      
      {Object.entries(status.byStation).map(([station, conns]) => (
        <div key={station} className="station-group">
          <h2>{station === 'unassigned' ? 'Unassigned' : `Station ${station}`}</h2>
          <ul>
            {conns.map(conn => (
              <li key={conn.id}>
                Socket {conn.id.substring(0, 8)}... 
                {' - '}
                Brigade: {conn.brigadeId || 'N/A'}
                {' - '}
                Rooms: {conn.rooms.join(', ')}
              </li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
}
```

**Estimated Effort:** 2-3 hours  
**Risk:** Low (monitoring only, no data changes)

---

### Priority 3: MEDIUM (Fix Within 2 Weeks)

#### Fix 3.1: Add Audit Logging for Cross-Brigade Access Attempts

**Objective:** Log any attempts to access data outside assigned brigade

**Implementation:**

File: `/backend/src/middleware/auditLogger.ts` (NEW)

```typescript
import { Request, Response, NextFunction } from 'express';
import { logger } from '../services/logger';

export function auditBrigadeAccess(req: Request, res: Response, next: NextFunction) {
  const stationId = req.headers['x-station-id'] as string;
  const requestedResource = req.path;
  const method = req.method;
  
  // Log all brigade-sensitive operations
  logger.info('Brigade access audit', {
    stationId,
    path: requestedResource,
    method,
    userId: req.headers['x-user-id'], // If user auth exists
    timestamp: new Date().toISOString(),
  });
  
  next();
}
```

Apply to all brigade-sensitive routes.

**Estimated Effort:** 1-2 hours  
**Risk:** Low (logging only)

---

## Testing Strategy

### Manual Testing Checklist

- [ ] **Test 1:** Open two browsers with different stations ‚Üí Verify no cross-brigade WebSocket events
- [ ] **Test 2:** Switch stations ‚Üí Verify cached data is isolated
- [ ] **Test 3:** Go offline ‚Üí Switch stations ‚Üí Come online ‚Üí Verify queued actions use correct context
- [ ] **Test 4:** Create event in Station A ‚Üí Verify Station B does not see it in real-time
- [ ] **Test 5:** Perform truck check in Station A ‚Üí Verify Station B does not receive updates
- [ ] **Test 6:** Create/update/delete station ‚Üí Verify appropriate clients receive notifications
- [ ] **Test 7:** Join station room ‚Üí Check Socket.io admin UI shows correct room membership
- [ ] **Test 8:** Monitor network traffic ‚Üí Verify no cross-brigade data in WebSocket frames

### Automated Testing Checklist

- [ ] **Unit tests:** WebSocket room joining logic
- [ ] **Unit tests:** Offline cache with station context
- [ ] **Integration tests:** WebSocket broadcast isolation
- [ ] **Integration tests:** API endpoints with station filtering
- [ ] **E2E tests:** Full user flow with station switching

---

## Performance Impact Assessment

### WebSocket Room-Based Filtering

**Expected Impact:** Minimal (< 5% overhead)

- Room-based routing is a core Socket.io feature, optimized for performance
- Broadcasting to rooms is actually MORE efficient than global broadcasts (fewer clients to notify)
- Memory overhead: ~100 bytes per room assignment per client

### Offline Cache with Station Context

**Expected Impact:** Negligible

- Cache key prefix adds ~20 bytes per entry
- No performance impact on read/write operations
- May slightly increase IndexedDB storage usage

---

## Rollout Plan

### Phase 1: Non-Breaking Changes (Week 1)

1. Add audit logging to all brigade-sensitive endpoints
2. Add monitoring dashboard for WebSocket connections
3. Deploy to staging environment

### Phase 2: WebSocket Room Implementation (Week 2)

1. Implement room joining logic on backend
2. Update frontend to send `join-station` event
3. Deploy to staging ‚Üí Test extensively
4. Gradual rollout to production (canary deployment)

### Phase 3: Offline Storage Updates (Week 3)

1. Implement station-scoped cache keys
2. Add cache clearing on station switch
3. Deploy to staging ‚Üí Test offline scenarios
4. Rollout to production

### Phase 4: Validation & Monitoring (Week 4)

1. Run automated test suite
2. Monitor audit logs for anomalies
3. Gather user feedback
4. Document lessons learned

---

## Appendix: Additional Recommendations

### 1. Implement User Authentication

**Rationale:** Currently, station context is based on client-side selection without server-side authentication. Adding authentication would:
- Prevent malicious clients from joining arbitrary station rooms
- Enable user-level audit trails
- Support role-based access control (admin vs. member)

### 2. Add Rate Limiting to WebSocket Events

**Rationale:** Prevent abuse of WebSocket broadcasting

```typescript
// Example: Limit event emits per client
const eventRateLimits = new Map<string, number>();

socket.on('event-created', (data) => {
  const count = eventRateLimits.get(socket.id) || 0;
  if (count > 10) {
    logger.warn('Rate limit exceeded', { socketId: socket.id });
    return;
  }
  eventRateLimits.set(socket.id, count + 1);
  
  io.to(`station-${socket.stationId}`).emit('event-update', data);
});
```

### 3. Consider Brigade Access Control Lists (ACLs)

**Rationale:** Some users may legitimately need access to multiple brigades (e.g., district managers, coordinators). Implement ACLs to control multi-brigade access.

```typescript
interface UserBrigadeAccess {
  userId: string;
  brigadeIds: string[];
  role: 'admin' | 'manager' | 'member';
}
```

### 4. Add End-to-End Encryption for Sensitive Events

**Rationale:** Even with room-based filtering, sensitive data (e.g., personnel details) could benefit from encryption at rest and in transit.

### 5. Implement Brigade Data Retention Policies

**Rationale:** Define how long brigade data is retained and when it can be deleted, especially for inactive brigades.

---

## Conclusion

This audit identified **critical cross-brigade data contamination vulnerabilities** in the RFS Station Manager system, primarily due to global WebSocket broadcasts and station-agnostic offline caching.

**Key Findings:**
- üö® ALL WebSocket events broadcast globally without station/brigade filtering
- ‚ö†Ô∏è Offline cache does not isolate data by station
- ‚ö†Ô∏è Potential for queued actions to execute with wrong station context

**Remediation Priority:**
1. **CRITICAL:** Implement Socket.io room-based filtering (Priority 1)
2. **HIGH:** Add station context to offline cache (Priority 1)
3. **MEDIUM:** Add validation tests and monitoring (Priority 2)

**Next Steps:**
1. Review this audit report with the development team
2. Prioritize fixes based on risk and effort
3. Implement changes incrementally with thorough testing
4. Monitor production for any brigade isolation issues
5. Document lessons learned for future development

**Estimated Total Effort:** 15-20 hours across 3-4 weeks

---

## Document Control

- **Version:** 1.0
- **Date:** 2026-02-07
- **Author:** GitHub Copilot (AI Agent)
- **Reviewed By:** [Pending]
- **Approved By:** [Pending]
- **Next Review Date:** 2026-03-07 (1 month)

---

## References

- [Socket.io Rooms Documentation](https://socket.io/docs/v4/rooms/)
- [IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
- [OWASP Data Validation](https://owasp.org/www-community/vulnerabilities/)
- RFS Station Manager Repository: `/home/runner/work/Station-Manager/Station-Manager`

---

**END OF AUDIT REPORT**
